<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Audio Joiner | Merge Audio Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .file-drop-zone {
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .file-drop-zone.dragover {
            background-color: #e0e7ff;
            border-color: #4f46e5;
        }
        .loader {
            border: 4px solid #f3f4f6;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .track-item {
            cursor: grab;
        }
        .track-item:active {
            cursor: grabbing;
        }
        .track-item.dragging {
            opacity: 0.5;
            background: #eef2ff;
        }
    </style>
</head>
<body class="bg-slate-50 text-gray-800 antialiased">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200">
        <div class="container mx-auto px-4 sm:px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-2">
                <i data-lucide="git-merge" class="text-indigo-600 w-7 h-7"></i>
                <h1 class="text-xl sm:text-2xl font-bold text-gray-900">AI Audio Joiner</h1>
            </div>
        </div>
    </header>

    <main class="container mx-auto px-4 sm:px-6 py-8 sm:py-12">
        <div class="max-w-4xl mx-auto">
            <!-- Hero Section -->
            <div class="text-center mb-8">
                <h1 class="text-3xl md:text-4xl font-extrabold text-gray-900">Online Audio Joiner</h1>
                <p class="mt-4 text-lg text-gray-600">
                    Merge multiple audio tracks into a single file. Supports various formats like MP3 and WAV.
                </p>
            </div>

            <!-- Main Application -->
            <div id="app" class="bg-white p-4 sm:p-8 rounded-2xl shadow-lg border border-gray-200">
                
                <!-- 1. Upload View -->
                <div id="upload-view">
                    <input type="file" id="audio-file-input" class="hidden" accept="audio/*" multiple>
                    <label for="audio-file-input" id="file-drop-zone" class="file-drop-zone flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <i data-lucide="upload-cloud" class="w-10 h-10 mb-4 text-gray-500"></i>
                            <p class="mb-2 text-sm text-gray-500"><span class="font-semibold">Click to upload</span> or drag and drop</p>
                            <p class="text-xs text-gray-500">Upload two or more audio files</p>
                        </div>
                    </label>
                </div>
                
                <!-- 2. Loading View -->
                <div id="processing-view" class="hidden text-center py-16">
                    <div class="loader mx-auto"></div>
                    <p id="processing-text" class="mt-4 text-lg font-medium text-gray-600">Processing audio...</p>
                </div>

                <!-- 3. Editor View -->
                <div id="editor-view" class="hidden">
                    <h3 class="text-lg font-semibold mb-4 text-gray-800">Your Tracks</h3>
                    <p class="text-sm text-gray-500 mb-4">Drag and drop to reorder the tracks. The topmost track will play first.</p>
                    <div id="track-list" class="space-y-2 border border-gray-200 rounded-lg p-2">
                        <!-- Track items will be inserted here -->
                    </div>
                    <div class="mt-6 flex flex-col sm:flex-row justify-between items-center gap-4">
                        <button id="add-more-btn" class="w-full sm:w-auto px-4 py-2 bg-gray-200 text-gray-800 font-semibold rounded-lg hover:bg-gray-300 transition text-sm">Add More Tracks</button>
                        <div class="flex gap-2">
                            <button id="clear-all-btn" class="w-full sm:w-auto px-4 py-2 bg-red-100 text-red-700 font-semibold rounded-lg hover:bg-red-200 transition text-sm">Clear All</button>
                            <button id="merge-btn" class="w-full sm:w-auto px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition text-sm">Merge Audio</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Download View -->
            <div id="download-view" class="hidden text-center mt-8">
                 <h2 class="text-2xl font-bold text-gray-900">Your Merged Audio is Ready!</h2>
                 <a id="download-link" class="mt-4 inline-block bg-green-500 text-white font-bold text-lg px-8 py-4 rounded-lg hover:bg-green-600 transition-all">
                    Download Merged Audio
                 </a>
                 <button id="join-another-btn" class="mt-4 block mx-auto text-indigo-600 hover:underline">Join More Files</button>
            </div>
        </div>
    </main>

    <script>
    // Initialize Lucide Icons
    lucide.createIcons();

    // DOM Elements
    const uploadView = document.getElementById('upload-view');
    const processingView = document.getElementById('processing-view');
    const processingText = document.getElementById('processing-text');
    const editorView = document.getElementById('editor-view');
    const downloadView = document.getElementById('download-view');
    
    const audioFileInput = document.getElementById('audio-file-input');
    const fileDropZone = document.getElementById('file-drop-zone');
    const trackList = document.getElementById('track-list');

    const addMoreBtn = document.getElementById('add-more-btn');
    const clearAllBtn = document.getElementById('clear-all-btn');
    const mergeBtn = document.getElementById('merge-btn');
    
    const downloadLink = document.getElementById('download-link');
    const joinAnotherBtn = document.getElementById('join-another-btn');

    // App State
    let audioContext;
    let audioTracks = []; // Array of objects: { name: string, buffer: AudioBuffer }

    // Web Audio API check
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    try {
        audioContext = new AudioContext();
    } catch (e) {
        alert('Web Audio API is not supported in this browser');
    }

    // --- File Handling ---
    fileDropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        fileDropZone.classList.add('dragover');
    });
    fileDropZone.addEventListener('dragleave', (e) => {
        e.preventDefault();
        fileDropZone.classList.remove('dragover');
    });
    fileDropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        fileDropZone.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
    });
    audioFileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    addMoreBtn.addEventListener('click', () => audioFileInput.click());

    async function handleFiles(files) {
        if (files.length === 0) return;

        uploadView.classList.add('hidden');
        editorView.classList.add('hidden');
        processingText.textContent = `Processing ${files.length} file(s)...`;
        processingView.classList.remove('hidden');

        const decodePromises = Array.from(files).map(file => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    audioContext.decodeAudioData(e.target.result)
                        .then(buffer => resolve({ name: file.name, buffer }))
                        .catch(reject);
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        });

        try {
            const newTracks = await Promise.all(decodePromises);
            audioTracks.push(...newTracks);
            renderTrackList();
            processingView.classList.add('hidden');
            editorView.classList.remove('hidden');
        } catch (error) {
            alert('Error decoding one or more audio files. Please try again with valid files.');
            console.error(error);
            resetApp();
        }
    }

    // --- UI Rendering & Drag-and-Drop ---
    function renderTrackList() {
        trackList.innerHTML = '';
        if (audioTracks.length === 0) {
            resetApp();
            return;
        }

        audioTracks.forEach((track, index) => {
            const trackElement = document.createElement('div');
            trackElement.className = 'track-item flex items-center justify-between p-3 bg-gray-50 border rounded-lg';
            trackElement.setAttribute('draggable', 'true');
            trackElement.dataset.index = index;

            trackElement.innerHTML = `
                <div class="flex items-center gap-3">
                    <i data-lucide="grip-vertical" class="text-gray-400"></i>
                    <span class="font-medium text-sm">${track.name}</span>
                </div>
                <button data-index="${index}" class="remove-btn p-1 text-gray-500 hover:text-red-600 rounded-full">
                    <i data-lucide="x" class="w-4 h-4"></i>
                </button>
            `;
            trackList.appendChild(trackElement);
        });

        lucide.createIcons();
        addDragAndDropHandlers();
    }
    
    function addDragAndDropHandlers() {
        const tracks = trackList.querySelectorAll('.track-item');
        let dragSrcElement = null;

        function handleDragStart(e) {
            dragSrcElement = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
            this.classList.add('dragging');
        }

        function handleDragOver(e) {
            if (e.preventDefault) e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleDrop(e) {
            if (e.stopPropagation) e.stopPropagation();
            if (dragSrcElement !== this) {
                const srcIndex = parseInt(dragSrcElement.dataset.index);
                const destIndex = parseInt(this.dataset.index);

                // Reorder the audioTracks array
                const [removed] = audioTracks.splice(srcIndex, 1);
                audioTracks.splice(destIndex, 0, removed);
                
                renderTrackList();
            }
            return false;
        }

        function handleDragEnd() {
            tracks.forEach(item => item.classList.remove('dragging'));
        }

        tracks.forEach(item => {
            item.addEventListener('dragstart', handleDragStart, false);
            item.addEventListener('dragover', handleDragOver, false);
            item.addEventListener('drop', handleDrop, false);
            item.addEventListener('dragend', handleDragEnd, false);
        });
        
        document.querySelectorAll('.remove-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const indexToRemove = parseInt(e.currentTarget.dataset.index);
                audioTracks.splice(indexToRemove, 1);
                renderTrackList();
            });
        });
    }

    // --- Audio Merging ---
    mergeBtn.addEventListener('click', () => {
        if (audioTracks.length < 2) {
            alert('Please add at least two audio tracks to merge.');
            return;
        }
        
        processingText.textContent = 'Merging audio...';
        editorView.classList.add('hidden');
        processingView.classList.remove('hidden');

        // Use a timeout to allow the UI to update before the heavy work
        setTimeout(() => {
            try {
                const mergedBuffer = mergeAudioBuffers(audioTracks.map(t => t.buffer));
                const wavBlob = bufferToWave(mergedBuffer);
                const url = URL.createObjectURL(wavBlob);
                
                downloadLink.href = url;
                downloadLink.download = 'merged_audio.wav';
    
                processingView.classList.add('hidden');
                downloadView.classList.remove('hidden');
            } catch (error) {
                alert('An error occurred while merging audio.');
                console.error(error);
                resetApp();
            }
        }, 100);
    });
    
    function mergeAudioBuffers(buffers) {
        const totalLength = buffers.reduce((sum, buffer) => sum + buffer.length, 0);
        // Use the sample rate and channel count of the first track as the standard
        const sampleRate = buffers[0].sampleRate;
        const numberOfChannels = buffers[0].numberOfChannels;
        
        const mergedBuffer = audioContext.createBuffer(numberOfChannels, totalLength, sampleRate);
        
        let offset = 0;
        for (const buffer of buffers) {
            if (buffer.numberOfChannels !== numberOfChannels || buffer.sampleRate !== sampleRate) {
                // In a real app, you might want to resample/remix here.
                // For simplicity, we'll throw an error if formats don't match.
                throw new Error('All audio files must have the same sample rate and channel count.');
            }
            for (let channel = 0; channel < numberOfChannels; channel++) {
                mergedBuffer.getChannelData(channel).set(buffer.getChannelData(channel), offset);
            }
            offset += buffer.length;
        }
        return mergedBuffer;
    }

    // --- App Controls ---
    clearAllBtn.addEventListener('click', resetApp);
    joinAnotherBtn.addEventListener('click', resetApp);
    
    function resetApp() {
        audioTracks = [];
        audioFileInput.value = '';
        uploadView.classList.remove('hidden');
        editorView.classList.add('hidden');
        downloadView.classList.add('hidden');
        processingView.classList.add('hidden');
        trackList.innerHTML = '';
    }
    
    // --- WAV Encoding (same as in Audio Cutter) ---
    function bufferToWave(abuffer) {
        const numOfChan = abuffer.numberOfChannels,
              length = abuffer.length * numOfChan * 2 + 44,
              buffer = new ArrayBuffer(length),
              view = new DataView(buffer),
              channels = [],
              sampleRate = abuffer.sampleRate;

        let offset = 0, pos = 0;

        const setUint16 = (data) => { view.setUint16(pos, data, true); pos += 2; }
        const setUint32 = (data) => { view.setUint32(pos, data, true); pos += 4; }

        setUint32(0x46464952); // "RIFF"
        setUint32(length - 8); // file length - 8
        setUint32(0x45564157); // "WAVE"
        setUint32(0x20746d66); // "fmt " chunk
        setUint32(16);
        setUint16(1); // PCM
        setUint16(numOfChan);
        setUint32(sampleRate);
        setUint32(sampleRate * 2 * numOfChan); // avg. bytes/sec
        setUint16(numOfChan * 2); // block-align
        setUint16(16); // 16-bit
        setUint32(0x61746164); // "data" - chunk
        setUint32(length - pos - 4);

        for (let i = 0; i < abuffer.numberOfChannels; i++) {
            channels.push(abuffer.getChannelData(i));
        }

        while (pos < length) {
            for (let i = 0; i < numOfChan; i++) {
                let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
            offset++;
        }

        return new Blob([buffer], {type: "audio/wav"});
    }

</script>
</body>
</html>
